<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"/>
<title>Skater — Fuller Recreation v2 (UMD, Pan/Orbit/Tilt)</title>
<style>
  html,body{margin:0;height:100%;background:#fff;overscroll-behavior:none;}
  #app{position:fixed;inset:0}
  .hud{position:fixed;left:8px;top:8px;display:flex;gap:8px;flex-wrap:wrap;z-index:3}
  .btn{background:rgba(255,255,255,.95);border:1px solid rgba(0,0,0,.2);color:#000;border-radius:10px;padding:8px 10px;
       font:600 12px/1 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .legend{position:fixed;right:8px;top:8px;color:#000;background:rgba(255,255,255,.9);padding:8px 10px;border-radius:10px;
          font:12px/1.3 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #log{position:fixed;left:8px;bottom:8px;color:#060;background:rgba(255,255,255,.92);font:11px/1.2 ui-monospace,Menlo,Consolas,monospace;
       padding:6px 8px;border-radius:8px;max-width:80vw;white-space:pre-wrap}
</style>
</head>
<body>
<canvas id="app"></canvas>
<div class="hud">
  <button class="btn" id="pause">Pause</button>
  <button class="btn" id="recenter">Recenter</button>
  <button class="btn" id="toggleBackplate">Backplate</button>
  <button class="btn" id="toggleLamps">Lamps</button>
</div>
<div class="legend">
  <b>Controls</b><br/>
  • Left‑drag: <b>Orbit</b><br/>
  • Right‑drag / ⌥Alt+Drag: <b>Pan</b><br/>
  • Middle‑drag / ⌘Cmd+Drag: <b>Tilt (roll)</b><br/>
  • Wheel / Pinch: <b>Zoom</b><br/>
  • Double‑tap/click: <b>Pause</b>
</div>
<div id="log"></div>

<!-- UMD build (no modules) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
(function(){
  const logEl = document.getElementById('log');
  const log = (m)=>{ logEl.textContent = m; };

  try{
    // Renderer / scene / camera
    const canvas = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 2000);

    // Bright skybox (solid white cube faces)
    (function(){
      const loader = new THREE.CubeTextureLoader();
      const data = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAusB9Zs7M7cAAAAASUVORK5CYII=";
      const cubemap = loader.load([data,data,data,data,data,data], ()=>log('✅ Skybox loaded'));
      cubemap.colorSpace = THREE.SRGBColorSpace;
      scene.background = cubemap;
    })();

    // Custom Controls: orbit, pan, tilt(roll), zoom
    const Controls = (function(){
      let theta = 0.55, phi = 0.95, radius = 10, roll = 0.0;
      const target = new THREE.Vector3(0,1.4,0);

      function applyCam(){
        // Build orientation from yaw(theta), pitch(phi), roll
        const dir = new THREE.Vector3(
          Math.sin(phi)*Math.cos(theta),
          Math.cos(phi),
          Math.sin(phi)*Math.sin(theta)
        );
        camera.position.copy(target).addScaledVector(dir, radius);
        camera.lookAt(target);
        camera.rotation.z = roll;
      }
      applyCam();

      function orbit(dx, dy){
        theta -= dx*2.5;
        phi   -= dy*2.0;
        const EPS = 0.001;
        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));
        applyCam();
      }
      function pan(dx, dy){
        // Pan relative to camera axes
        const panSpeed = radius * 0.8;
        const right = new THREE.Vector3();
        const up = new THREE.Vector3(0,1,0);
        right.crossVectors(camera.getWorldDirection(new THREE.Vector3()), up).normalize();
        up.copy(new THREE.Vector3(0,1,0)).applyAxisAngle(right, 0); // world up
        target.addScaledVector(right, -dx * panSpeed);
        target.addScaledVector(new THREE.Vector3(0,1,0), dy * panSpeed);
        applyCam();
      }
      function tilt(dz){
        roll += dz*2.5;
        applyCam();
      }
      function dolly(delta){
        radius *= (1 + delta);
        radius = Math.max(3, Math.min(60, radius));
        applyCam();
      }

      // Pointer handling
      let state = { dragging:false, btn:0, alt:false, meta:false, startX:0, startY:0 };
      function onDown(e){
        state.dragging = true;
        state.btn = e.button;
        state.alt = e.altKey;
        state.meta = e.metaKey || e.ctrlKey;
        state.startX = e.clientX; state.startY = e.clientY;
        e.preventDefault();
      }
      function onMove(e){
        if(!state.dragging) return;
        const dx = (e.clientX - state.startX) / window.innerWidth;
        const dy = (e.clientY - state.startY) / window.innerHeight;
        state.startX = e.clientX; state.startY = e.clientY;
        if(state.btn===0 && !state.alt && !state.meta){ orbit(dx, dy); }
        else if(state.btn===2 || state.alt){ pan(dx, dy); }
        else if(state.btn===1 || state.meta){ tilt(dx); }
      }
      function onUp(){ state.dragging=false; }

      function onWheel(e){
        e.preventDefault();
        const delta = (e.deltaY>0? 0.12 : -0.12);
        dolly(delta);
      }

      // Touch: 1 finger orbit, 2 finger pan, pinch zoom
      let tState = { prev:null, dist:0 };
      function tStart(e){
        if(e.touches.length===1){
          tState.prev = {x:e.touches[0].clientX, y:e.touches[0].clientY};
        }else if(e.touches.length===2){
          const [a,b] = e.touches;
          tState.prev = {x:(a.clientX+b.clientX)/2, y:(a.clientY+b.clientY)/2};
          const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY;
          tState.dist = Math.hypot(dx,dy);
        }
      }
      function tMove(e){
        if(e.touches.length===1 && tState.prev){
          const t = e.touches[0];
          const dx = (t.clientX - tState.prev.x)/window.innerWidth;
          const dy = (t.clientY - tState.prev.y)/window.innerHeight;
          orbit(dx, dy);
          tState.prev = {x:t.clientX, y:t.clientY};
        }else if(e.touches.length===2){
          const [a,b] = e.touches;
          const cx=(a.clientX+b.clientX)/2, cy=(a.clientY+b.clientY)/2;
          const dx=(cx - tState.prev.x)/window.innerWidth;
          const dy=(cy - tState.prev.y)/window.innerHeight;
          pan(dx, dy);
          const ddx=a.clientX-b.clientX, ddy=a.clientY-b.clientY;
          const dist = Math.hypot(ddx,ddy);
          const delta = (tState.dist===0)?0: (tState.dist - dist)/600;
          dolly(delta);
          tState.prev = {x:cx, y:cy}; tState.dist = dist;
        }
        e.preventDefault();
      }
      function tEnd(){ tState.prev=null; tState.dist=0; }

      // listeners
      window.addEventListener('contextmenu', (e)=>e.preventDefault());
      window.addEventListener('mousedown', onDown);
      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp);
      window.addEventListener('wheel', onWheel, {passive:false});
      window.addEventListener('touchstart', tStart, {passive:false});
      window.addEventListener('touchmove', tMove, {passive:false});
      window.addEventListener('touchend', tEnd, {passive:false});

      // API
      return {
        setTarget(x,y,z){ target.set(x,y,z); applyCam(); },
        setRadius(r){ radius=r; applyCam(); },
        reset(){ theta=0.55; phi=0.95; radius=10; roll=0; target.set(0,1.4,0); applyCam(); }
      };
    })();

    // Backplate (photo) toggle
    const backplate = new THREE.Group(); scene.add(backplate);
    (function(){
      const url = './assets/reference.png';
      const img = new Image();
      img.onload = function(){
        const tex = new THREE.Texture(img); tex.needsUpdate = true; tex.colorSpace = THREE.SRGBColorSpace;
        const ratio = img.width / img.height;
        const h = 8, w = h*ratio;
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w,h),
                    new THREE.MeshBasicMaterial({ map: tex, depthWrite:false }));
        mesh.position.set(0,3.2,-9);
        backplate.add(mesh);
      };
      img.src = url;
    })();

    // Environment + lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0xdddddd, 0.75);
    scene.add(hemi);

    // Ground plane
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(80,80),
      new THREE.MeshStandardMaterial({ color:0xeeeeee, metalness:0.5, roughness:0.25 })
    );
    ground.rotation.x = -Math.PI/2; scene.add(ground);

    // Rail + curb
    (function(){
      const curb = new THREE.Mesh(
        new THREE.BoxGeometry(60,0.12,0.4),
        new THREE.MeshStandardMaterial({ color:0xdedede, metalness:0.2, roughness:0.5 })
      );
      curb.position.set(0,0.06,-2.2); scene.add(curb);
      const rail = new THREE.Mesh(
        new THREE.CylinderGeometry(0.06,0.06,6,16),
        new THREE.MeshStandardMaterial({ color:0x888888, metalness:0.6, roughness:0.35 })
      );
      rail.rotation.z = Math.PI/2; rail.position.set(0,0.6,-1.6); scene.add(rail);
    })();

    // Lamps row with toggle
    const lamps = new THREE.Group(); scene.add(lamps);
    function addLamp(x,z,intensity){
      const pole = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05,0.05,3.2,16),
        new THREE.MeshStandardMaterial({ color: 0x444444, metalness:0.6, roughness:0.45 })
      );
      pole.position.set(x,1.6,z); lamps.add(pole);
      const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.18, 20, 12),
        new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0xfff0a0, emissiveIntensity:2.0 }));
      bulb.position.set(x,3.3,z); lamps.add(bulb);
      const light = new THREE.PointLight(0xfff2b0, intensity, 18, 2);
      light.position.copy(bulb.position); lamps.add(light);
    }
    [-3, -1, 1.5, 3.8].forEach((x,i)=> addLamp(x, 1.1 + 0.5*(i%2), 1.8 + i*0.2));

    // Subject (skater + board)
    const subject = new THREE.Group(); scene.add(subject);
    const black = new THREE.MeshStandardMaterial({ color:0x000000, metalness:0.9, roughness:0.2 });

    // Build skater (silhouette for now; rigged GLB can replace later)
    const skater = new THREE.Group(); subject.add(skater);
    function add(mesh,p,r=[0,0,0],s=[1,1,1]){ mesh.position.set(p[0],p[1],p[2]); mesh.rotation.set(r[0],r[1],r[2]); mesh.scale.set(s[0],s[1],s[2]); skater.add(mesh); }
    const R=(d)=>d*Math.PI/180;
    add(new THREE.Mesh(new THREE.CapsuleGeometry(0.33,0.95,12,20), black), [0,2.05,0]);
    add(new THREE.Mesh(new THREE.SphereGeometry(0.26,20,16), black), [0,2.78,0]);
    add(new THREE.Mesh(new THREE.CapsuleGeometry(0.12,0.7,8,12), black), [-0.78,2.35,-0.08], [0,0,R(40)]);
    add(new THREE.Mesh(new THREE.CapsuleGeometry(0.12,0.7,8,12), black), [ 0.78,2.35,-0.08], [0,0,R(-38)]);
    add(new THREE.Mesh(new THREE.CapsuleGeometry(0.16,0.65,8,14), black), [-0.30,1.45,0.04], [0,0,R(72)]);
    add(new THREE.Mesh(new THREE.CapsuleGeometry(0.16,0.65,8,14), black), [ 0.30,1.45,0.04], [0,0,R(-70)]);
    skater.position.y = 1.45;

    // Board
    const board = new THREE.Group(); subject.add(board);
    board.add(new THREE.Mesh(new THREE.BoxGeometry(2.0,0.08,0.48), black));
    function wheel(){ return new THREE.Mesh(new THREE.TorusGeometry(0.09,0.04,10,20), black); }
    const wz=0.20, wx=0.60, wy=-0.1;
    [ [-wx,wy, wz],[ wx,wy, wz],[-wx,wy,-wz],[ wx,wy,-wz] ].forEach(p=>{ const w=wheel(); w.position.set(p[0],p[1],p[2]); board.add(w); });
    board.position.set(0,0.95,0);

    // Fake reflection: mirrored clone under ground with fade
    const reflector = new THREE.Group(); scene.add(reflector);
    (function(){
      const clone = subject.clone(true);
      clone.scale.y *= -1;
      clone.position.y = -0.001; // just below ground
      // Apply fade material override
      clone.traverse((o)=>{
        if(o.isMesh){
          o.material = new THREE.MeshStandardMaterial({ color:0x000000, metalness:0.9, roughness:0.25, transparent:true, opacity:0.35 });
        }
      });
      reflector.add(clone);
    })();

    // Auto-frame
    function frameSubject(padding=1.5){
      const box = new THREE.Box3().setFromObject(subject);
      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);
      center.y += size.y*0.15;
      Controls.setTarget(center.x, center.y, center.z);
      const maxDim = Math.max(size.x, size.y, size.z);
      Controls.setRadius(Math.max(7, maxDim*padding));
    }
    frameSubject();

    // UI
    let playing = true;
    document.getElementById('pause').onclick = ()=> playing = !playing;
    document.getElementById('recenter').onclick = ()=> frameSubject();
    document.getElementById('toggleBackplate').onclick = ()=> backplate.visible = !backplate.visible;
    document.getElementById('toggleLamps').onclick = ()=> lamps.visible = !lamps.visible;

    // Double click/tap to pause
    let lastTap=0;
    window.addEventListener('click', ()=>{
      const now = Date.now();
      if(now-lastTap<300){ playing = !playing; }
      lastTap = now;
    });

    // Animation
    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();
      if(playing){
        skater.position.y = 1.45 + Math.sin(t*1.4)*0.16;
        board.position.y  = 0.95 + Math.sin(t*1.5 + 1.2)*0.12;
        board.rotation.x  = Math.sin(t*3.2)*0.5;
        board.rotation.z  = Math.sin(t*2.1 + 1.2)*0.35;
      }
      renderer.render(scene, camera);
    }

    function onResize(){
      const w = window.innerWidth||320, h = window.innerHeight||480;
      camera.aspect = w/h; camera.updateProjectionMatrix();
      renderer.setSize(w,h,false);
    }
    window.addEventListener('resize', onResize, {passive:true});
    onResize();
    animate();
    log('✅ Full v2 loaded — Pan/Orbit/Tilt ready');
  }catch(err){
    document.getElementById('log').textContent = 'Error: '+err.message;
    console.error(err);
  }
})();
</script>
</body>
</html>
