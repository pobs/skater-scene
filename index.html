<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"/>
<title>Skater — Fuller Recreation v1 (Three.js Mobile)</title>
<style>
  html,body{margin:0;height:100%;background:#000;overscroll-behavior:none;}
  #app{position:fixed;inset:0}
  .hint{position:fixed;left:0;right:0;bottom:0;color:#fff;background:linear-gradient(180deg,transparent,rgba(0,0,0,.6));font:600 12px/1.2 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;text-align:center;padding:10px env(safe-area-inset-bottom) 14px;letter-spacing:.2px}
  .btns{position:fixed;right:8px;top:8px;display:flex;gap:8px;z-index:3}
  .btn{background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.25);color:#fff;border-radius:10px;padding:8px 10px;font:600 12px/1 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
</style>
</head>
<body>
<canvas id="app"></canvas>
<div class="btns">
  <button class="btn" id="toggleRipple">Ripples</button>
  <button class="btn" id="toggleBackplate">Backplate</button>
</div>
<div class="hint">Drag to orbit • Pinch to zoom • Tap to pause/play</div>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
import { Reflector } from 'https://unpkg.com/three@0.160.0/examples/jsm/objects/Reflector.js';

const canvas = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
const scene = new THREE.Scene();

// Camera & controls
const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 2000);
camera.position.set(6, 2.2, 9);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.06;
controls.minDistance = 4; controls.maxDistance = 16;
controls.minPolarAngle = THREE.MathUtils.degToRad(10);
controls.maxPolarAngle = THREE.MathUtils.degToRad(80);
controls.target.set(0,1.4,0);

// Backplate (photo)
const backplateGroup = new THREE.Group();
scene.add(backplateGroup);
{
  const texLoader = new THREE.TextureLoader();
  texLoader.load('./assets/reference.png', (tex)=>{
    tex.colorSpace = THREE.SRGBColorSpace;
    const ratio = tex.image.width / tex.image.height;
    const h = 8, w = h*ratio;
    const mesh = new THREE.Mesh(
      new THREE.PlaneGeometry(w, h),
      new THREE.MeshBasicMaterial({ map: tex, depthWrite:false })
    );
    mesh.position.set(0, 3.2, -9);
    backplateGroup.add(mesh);
  });
}

// Gradient skydome (kept subtle; backplate is primary)
{
  const geo = new THREE.SphereGeometry(1000, 48, 24); geo.scale(-1,1,1);
  const mat = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    transparent: true,
    uniforms: {
      top: { value: new THREE.Color(0x0a2a3a) },
      bot: { value: new THREE.Color(0x180d10) },
      alpha: { value: 0.65 }
    },
    vertexShader: `varying vec3 vPos; void main(){ vPos=normalize(position); gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.); }`,
    fragmentShader: `varying vec3 vPos; uniform vec3 top; uniform vec3 bot; uniform float alpha;
      void main(){ float h=clamp(vPos.y*0.5+0.5,0.,1.); vec3 col=mix(bot,top,h); gl_FragColor=vec4(col,alpha);} `
  });
  scene.add(new THREE.Mesh(geo, mat));
}

// Ground: reflector + animated ripple normal map
let rippleOn = true;
const rippleRT = new THREE.WebGLRenderTarget(512, 512,{depthBuffer:false});
const rippleScene = new THREE.Scene();
const rippleCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
{
  const quad = new THREE.Mesh(
    new THREE.PlaneGeometry(2,2),
    new THREE.ShaderMaterial({
      uniforms: { t: { value: 0 } },
      fragmentShader: `precision highp float;
        uniform float t;
        // two moving sin waves to fake ripples, output packed normal.xy
        void main(){
          vec2 uv = gl_FragCoord.xy/vec2(512.0,512.0);
          float a = sin((uv.x*20.0 + t*0.8)) * 0.5 + 0.5;
          float b = sin((uv.y*25.0 - t*0.6 + 1.57)) * 0.5 + 0.5;
          float c = sin((uv.x*12.0 + uv.y*18.0 + t*0.9)) * 0.5 + 0.5;
          vec2 n = (vec2(a-b, c-a) - 0.5) * 0.9; // pseudo-normal xy
          gl_FragColor = vec4(n*0.5+0.5, 0.5, 1.0);
        }`
    })
  );
  rippleScene.add(quad);
}

const puddleMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 1.0, roughness: 0.08 });
const puddle = new Reflector(new THREE.PlaneGeometry(60,60), {
  textureWidth: 1024, textureHeight: 1024, clipBias: 0.003, color: 0x111111
});
puddle.rotation.x = -Math.PI/2;
scene.add(puddle);

// Apply normal map from RT to puddle via onBeforeCompile
puddle.material.onBeforeCompile = (shader)=>{
  shader.uniforms.rippleMap = { value: rippleRT.texture };
  shader.uniforms.rippleOn = { value: rippleOn ? 1.0 : 0.0 };
  shader.fragmentShader = shader.fragmentShader.replace(
    '#include <normal_fragment_begin>',
    `#include <normal_fragment_begin>
     if (rippleOn>0.5){
       vec3 nrm = texture2D(rippleMap, vUv).xyz * 2.0 - 1.0;
       normal = normalize( normal + nrm*0.25 );
     }`
  );
  puddle.userData.shader = shader;
};

// Curb + rail silhouette
{
  const curb = new THREE.Mesh(new THREE.BoxGeometry(60, 0.12, 0.35),
    new THREE.MeshStandardMaterial({ color: 0x0f0f0f, metalness:0.4, roughness:0.4 }));
  curb.position.set(0, 0.06, -2.4);
  scene.add(curb);

  const rail = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,6,16),
    new THREE.MeshStandardMaterial({ color: 0x0a0a0a, metalness:0.6, roughness:0.4 }));
  rail.rotation.z = Math.PI/2;
  rail.position.set(0, 0.6, -1.8);
  scene.add(rail);
}

// Silhouette materials
const silhouetteMat = new THREE.MeshStandardMaterial({ color: 0x000000, metalness:0.9, roughness:0.2 });
const emissiveMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xfff0a0, emissiveIntensity: 2.2 });

// Skater group (refined proportions)
const skater = new THREE.Group(); scene.add(skater);
{
  const add=(m,p,r=[0,0,0],s=[1,1,1])=>{ m.position.set(...p); m.rotation.set(...r.map(THREE.MathUtils.degToRad)); m.scale.set(...s); skater.add(m); };
  add(new THREE.Mesh(new THREE.CapsuleGeometry(0.33, 0.95, 12, 20), silhouetteMat), [0,2.05,0]);
  add(new THREE.Mesh(new THREE.SphereGeometry(0.26, 20, 16), silhouetteMat), [0,2.78,0]);
  add(new THREE.Mesh(new THREE.CapsuleGeometry(0.12,0.7,8,12), silhouetteMat), [-0.78,2.35,-0.08], [0,0,40]);
  add(new THREE.Mesh(new THREE.CapsuleGeometry(0.12,0.7,8,12), silhouetteMat), [ 0.78,2.35,-0.08], [0,0,-38]);
  add(new THREE.Mesh(new THREE.CapsuleGeometry(0.16,0.65,8,14), silhouetteMat), [-0.30,1.45,0.04], [0,0,72]);
  add(new THREE.Mesh(new THREE.CapsuleGeometry(0.16,0.65,8,14), silhouetteMat), [ 0.30,1.45,0.04], [0,0,-70]);
  skater.position.y = 1.45;
}

// Skateboard (silhouette, larger wheels)
const board = new THREE.Group(); scene.add(board);
{
  const deck = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.08, 0.48), silhouetteMat);
  board.add(deck);
  const makeWheel=()=>new THREE.Mesh(new THREE.TorusGeometry(0.09, 0.04, 10, 20), silhouetteMat);
  const z=0.20, x=0.60, y=-0.1;
  const w=[makeWheel(),makeWheel(),makeWheel(),makeWheel()];
  w[0].position.set(-x,y, z); w[1].position.set( x,y, z); w[2].position.set(-x,y,-z); w[3].position.set( x,y,-z);
  w.forEach(e=>board.add(e));
  board.position.set(0, 0.95, 0);
}

// Lamps row
function addLamp(x,z,intensity=2.0){
  const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,3.2,16),
    new THREE.MeshStandardMaterial({ color: 0x0b0b0b, metalness:0.6, roughness:0.4 }));
  pole.position.set(x,1.6,z); scene.add(pole);
  const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.18, 20, 12), emissiveMat);
  bulb.position.set(x,3.3,z); scene.add(bulb);
  const light = new THREE.PointLight(0xfff2b0, intensity, 18, 2); light.position.copy(bulb.position); scene.add(light);
}
[-3, -1, 1.5, 3.8].forEach((x,i)=> addLamp(x, 1.1 + 0.5*(i%2), 2.0 + i*0.2));

// Ambient/hemisphere
scene.add(new THREE.HemisphereLight(0xffe0aa, 0x081018, 0.35));

// UI buttons
const rippleBtn = document.getElementById('toggleRipple');
const backBtn = document.getElementById('toggleBackplate');
rippleBtn.addEventListener('click', ()=>{
  rippleOn = !rippleOn;
  if (puddle.userData.shader){ puddle.userData.shader.uniforms.rippleOn.value = rippleOn ? 1.0 : 0.0; }
});
backBtn.addEventListener('click', ()=>{
  backplateGroup.visible = !backplateGroup.visible;
});

// Animation
let playing = true;
window.addEventListener('pointerdown', (e)=>{
  // ignore taps on buttons
  const el = e.target; if (el.classList && el.classList.contains('btn')) return;
  playing = !playing;
});
const clock = new THREE.Clock();

function renderRipples(t){
  rippleScene.children[0].material.uniforms.t.value = t;
  renderer.setRenderTarget(rippleRT);
  renderer.render(rippleScene, rippleCam);
  renderer.setRenderTarget(null);
}

function animate(){
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  if(playing){
    renderRipples(t);
    // motion
    skater.position.y = 1.45 + Math.sin(t*1.4)*0.16;
    board.position.y  = 0.95 + Math.sin(t*1.5 + 1.2)*0.12;
    board.rotation.x  = Math.sin(t*3.2)*0.5;
    board.rotation.z  = Math.sin(t*2.1 + 1.2)*0.35;
  }

  controls.update();
  renderer.render(scene, camera);
}

// Resize
function onResize(){
  const w = window.innerWidth, h = window.innerHeight;
  camera.aspect = w/h; camera.updateProjectionMatrix();
  renderer.setSize(w, h, false);
}
window.addEventListener('resize', onResize, {passive:true});
onResize();
animate();
</script>
</body>
</html>
