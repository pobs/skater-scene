<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"/>
<title>Skater — Rig + GLB/FBX + Draco/Meshopt (UMD)</title>
<style>
  html,body{margin:0;height:100%;background:#fff;overscroll-behavior:none;}
  #app{position:fixed;inset:0}
  .hud{position:fixed;left:8px;top:8px;display:flex;gap:8px;flex-wrap:wrap;z-index:3}
  .btn{background:rgba(255,255,255,.95);border:1px solid rgba(0,0,0,.2);color:#000;border-radius:10px;padding:8px 10px;
       font:600 12px/1 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .legend{position:fixed;right:8px;top:8px;color:#000;background:rgba(255,255,255,.9);padding:8px 10px;border-radius:10px;
          font:12px/1.3 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #log{position:fixed;left:8px;bottom:8px;color:#060;background:rgba(255,255,255,.92);font:11px/1.2 ui-monospace,Menlo,Consolas,monospace;
       padding:6px 8px;border-radius:8px;max-width:80vw;white-space:pre-wrap}
  #file{display:none}
  .drop{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.25);
        color:#fff;font:700 20px/1.3 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;z-index:5;border:3px dashed #fff}
</style>
</head>
<body>
<canvas id="app"></canvas>

<div class="hud">
  <button class="btn" id="pause">Pause</button>
  <button class="btn" id="recenter">Recenter</button>
  <button class="btn" id="toggleBackplate">Backplate</button>
  <button class="btn" id="toggleLamps">Lamps</button>
  <button class="btn" id="toggleSilhouette">Silhouette</button>
  <button class="btn" id="loadModel">Load Model…</button>
  <input id="file" type="file" accept=".glb,.gltf,.fbx,model/gltf-binary,model/gltf+json,application/octet-stream">
</div>
<div class="legend">
  <b>Controls</b><br/>
  • Left‑drag: <b>Orbit</b> • Wheel: <b>Zoom</b><br/>
  • Right‑drag / ⌥Alt+Drag: <b>Pan</b><br/>
  • Middle‑drag / ⌘Cmd+Drag: <b>Tilt (roll)</b><br/>
  • Double‑click/tap: <b>Pause</b>
</div>
<div id="log"></div>
<div class="drop" id="drop">Drop GLB/GLTF/FBX here</div>

<!-- Three.js core (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<!-- Loaders (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/DRACOLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/libs/inflate.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/FBXLoader.js"></script>

<!-- Meshopt decoder (global MeshoptDecoder Promise) -->
<script src="https://unpkg.com/meshoptimizer/meshopt_decoder.js"></script>

<script>

(function(){
  const logEl = document.getElementById('log');
  const log = (m)=>{ logEl.textContent = m; console.log(m); };

  try{
    const canvas = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 2000);

    (function(){
      const loader = new THREE.CubeTextureLoader();
      const data = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAusB9Zs7M7cAAAAASUVORK5CYII=";
      const cubemap = loader.load([data,data,data,data,data,data], ()=>log('✅ Skybox loaded'));
      cubemap.colorSpace = THREE.SRGBColorSpace;
      scene.background = cubemap;
    })();

    const Controls = (function(){
      let theta = 0.55, phi = 0.95, radius = 10, roll = 0.0;
      const target = new THREE.Vector3(0,1.4,0);
      function applyCam(){ const dir = new THREE.Vector3(Math.sin(phi)*Math.cos(theta), Math.cos(phi), Math.sin(phi)*Math.sin(theta)); camera.position.copy(target).addScaledVector(dir, radius); camera.lookAt(target); camera.rotation.z = roll; }
      applyCam();
      function orbit(dx, dy){ theta -= dx*2.5; phi -= dy*2.0; phi=Math.max(0.001,Math.min(Math.PI-0.001,phi)); applyCam(); }
      function pan(dx, dy){ const panSpeed = radius * 0.8; const right = new THREE.Vector3().crossVectors(camera.getWorldDirection(new THREE.Vector3()), new THREE.Vector3(0,1,0)).normalize(); target.addScaledVector(right, -dx * panSpeed); target.addScaledVector(new THREE.Vector3(0,1,0), dy * panSpeed); applyCam(); }
      function tilt(dz){ roll += dz*2.5; applyCam(); }
      function dolly(delta){ radius *= (1 + delta); radius = Math.max(3, Math.min(60, radius)); applyCam(); }
      let state = { dragging:false, btn:0, alt:false, meta:false, startX:0, startY:0 };
      function onDown(e){ state.dragging=true; state.btn=e.button; state.alt=e.altKey; state.meta=e.metaKey||e.ctrlKey; state.startX=e.clientX; state.startY=e.clientY; e.preventDefault(); }
      function onMove(e){ if(!state.dragging) return; const dx=(e.clientX-state.startX)/window.innerWidth, dy=(e.clientY-state.startY)/window.innerHeight; state.startX=e.clientX; state.startY=e.clientY; if(state.btn===0 && !state.alt && !state.meta){ orbit(dx,dy); } else if(state.btn===2 || state.alt){ pan(dx,dy); } else if(state.btn===1 || state.meta){ tilt(dx); } }
      function onUp(){ state.dragging=false; }
      function onWheel(e){ e.preventDefault(); dolly(e.deltaY>0?0.12:-0.12); }
      let tState = { prev:null, dist:0 };
      function tStart(e){ if(e.touches.length===1){ tState.prev={x:e.touches[0].clientX,y:e.touches[0].clientY}; } else if(e.touches.length===2){ const [a,b]=e.touches; tState.prev={x:(a.clientX+b.clientX)/2,y:(a.clientY+b.clientY)/2}; const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; tState.dist=Math.hypot(dx,dy); } }
      function tMove(e){ if(e.touches.length===1 && tState.prev){ const t=e.touches[0]; const dx=(t.clientX-tState.prev.x)/window.innerWidth, dy=(t.clientY-tState.prev.y)/window.innerHeight; orbit(dx,dy); tState.prev={x:t.clientX,y:t.clientY}; } else if(e.touches.length===2){ const [a,b]=e.touches; const cx=(a.clientX+b.clientX)/2, cy=(a.clientY+b.clientY)/2; const dx=(cx-tState.prev.x)/window.innerWidth, dy=(cy-tState.prev.y)/window.innerHeight; pan(dx,dy); const ddx=a.clientX-b.clientX, ddy=a.clientY-b.clientY; const dist=Math.hypot(ddx,ddy); const delta = (tState.dist===0)?0: (tState.dist - dist)/600; dolly(delta); tState.prev={x:cx,y:cy}; tState.dist=dist; } e.preventDefault(); }
      function tEnd(){ tState.prev=null; tState.dist=0; }
      window.addEventListener('contextmenu', (e)=>e.preventDefault());
      window.addEventListener('mousedown', onDown);
      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp);
      window.addEventListener('wheel', onWheel, {passive:false});
      window.addEventListener('touchstart', tStart, {passive:false});
      window.addEventListener('touchmove', tMove, {passive:false});
      window.addEventListener('touchend', tEnd, {passive:false});
      return { setTarget(x,y,z){ target.set(x,y,z); applyCam(); }, setRadius(r){ radius=r; applyCam(); }, reset(){ theta=0.55; phi=0.95; radius=10; roll=0; target.set(0,1.4,0); applyCam(); } };
    })();

    const backplate = new THREE.Group(); scene.add(backplate);
    (function(){ const url='./assets/reference.png'; const img=new Image(); img.onload=function(){ const tex=new THREE.Texture(img); tex.needsUpdate=true; tex.colorSpace=THREE.SRGBColorSpace; const ratio=img.width/img.height; const h=8, w=h*ratio; const mesh=new THREE.Mesh(new THREE.PlaneGeometry(w,h), new THREE.MeshBasicMaterial({ map: tex, depthWrite:false })); mesh.position.set(0,3.2,-9); backplate.add(mesh); }; img.src=url; })();

    scene.add(new THREE.HemisphereLight(0xffffff, 0xdddddd, 0.75));
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(80,80), new THREE.MeshStandardMaterial({ color:0xeeeeee, metalness:0.5, roughness:0.25 })); ground.rotation.x=-Math.PI/2; scene.add(ground);
    (function(){ const curb=new THREE.Mesh(new THREE.BoxGeometry(60,0.12,0.4), new THREE.MeshStandardMaterial({ color:0xdedede, metalness:0.2, roughness:0.5 })); curb.position.set(0,0.06,-2.2); scene.add(curb); const rail=new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,6,16), new THREE.MeshStandardMaterial({ color:0x888888, metalness:0.6, roughness:0.35 })); rail.rotation.z=Math.PI/2; rail.position.set(0,0.6,-1.6); scene.add(rail); })();

    const lamps = new THREE.Group(); scene.add(lamps);
    function addLamp(x,z,intensity){ const pole=new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,3.2,16), new THREE.MeshStandardMaterial({ color:0x444444, metalness:0.6, roughness:0.45 })); pole.position.set(x,1.6,z); lamps.add(pole); const bulb=new THREE.Mesh(new THREE.SphereGeometry(0.18,20,12), new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0xfff0a0, emissiveIntensity:2.0 })); bulb.position.set(x,3.3,z); lamps.add(bulb); const light=new THREE.PointLight(0xfff2b0,intensity,18,2); light.position.copy(bulb.position); lamps.add(light); }
    [-3,-1,1.5,3.8].forEach((x,i)=> addLamp(x,1.1+0.5*(i%2),1.8+i*0.2));

    const subject = new THREE.Group(); scene.add(subject);
    const black = new THREE.MeshStandardMaterial({ color:0x000000, metalness:0.9, roughness:0.2 });
    const skater = new THREE.Group(); subject.add(skater);
    function add(mesh,p,r=[0,0,0],s=[1,1,1]){ mesh.position.set(p[0],p[1],p[2]); mesh.rotation.set(r[0],r[1],r[2]); mesh.scale.set(s[0],s[1],s[2]); skater.add(mesh); }
    const R=(d)=>d*Math.PI/180;
    add(new THREE.Mesh(new THREE.CapsuleGeometry(0.33,0.95,12,20), black), [0,2.05,0]);
    add(new THREE.Mesh(new THREE.SphereGeometry(0.26,20,16), black), [0,2.78,0]);
    add(new THREE.Mesh(new THREE.CapsuleGeometry(0.12,0.7,8,12), black), [-0.78,2.35,-0.08], [0,0,R(40)]);
    add(new THREE.Mesh(new THREE.CapsuleGeometry(0.12,0.7,8,12), black), [ 0.78,2.35,-0.08], [0,0,R(-38)]);
    add(new THREE.Mesh(new THREE.CapsuleGeometry(0.16,0.65,8,14), black), [-0.30,1.45,0.04], [0,0,R(72)]);
    add(new THREE.Mesh(new THREE.CapsuleGeometry(0.16,0.65,8,14), black), [ 0.30,1.45,0.04], [0,0,R(-70)]);
    skater.position.y=1.45;
    const board = new THREE.Group(); subject.add(board);
    board.add(new THREE.Mesh(new THREE.BoxGeometry(2.0,0.08,0.48), black));
    function wheel(){ return new THREE.Mesh(new THREE.TorusGeometry(0.09,0.04,10,20), black); }
    const wz=0.20, wx=0.60, wy=-0.1;
    [[-wx,wy, wz],[ wx,wy, wz],[-wx,wy,-wz],[ wx,wy,-wz]].forEach(p=>{ const w=wheel(); w.position.set(p[0],p[1],p[2]); board.add(w); });
    board.position.set(0,0.95,0);

    const mirror = new THREE.Group(); scene.add(mirror);
    (function(){ const clone=subject.clone(true); clone.scale.y*=-1; clone.position.y=-0.001; clone.traverse(o=>{ if(o.isMesh){ o.material=new THREE.MeshStandardMaterial({ color:0x000000, metalness:0.9, roughness:0.25, transparent:true, opacity:0.35 }); } }); mirror.add(clone); })();

    function frameSubject(padding=1.5){ const box=new THREE.Box3().setFromObject(subject); const size=new THREE.Vector3(); box.getSize(size); const center=new THREE.Vector3(); box.getCenter(center); center.y+=size.y*0.15; Controls.setTarget(center.x,center.y,center.z); const maxDim=Math.max(size.x,size.y,size.z); Controls.setRadius(Math.max(7, maxDim*padding)); }
    frameSubject();

    let forceSilhouette=false;
    document.getElementById('toggleSilhouette').onclick=()=>{ forceSilhouette=!forceSilhouette; traverseForSilhouette(subject, forceSilhouette); };
    function traverseForSilhouette(root, force){ root.traverse((o)=>{ if(o.isMesh && o.material){ if(!o.userData._origMat){ o.userData._origMat=o.material; } o.material = force ? new THREE.MeshStandardMaterial({ color:0x000000, metalness:0.9, roughness:0.2 }) : o.userData._origMat; } }); }

    const draco = new THREE.DRACOLoader();
    draco.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
    const gltfLoader = new THREE.GLTFLoader();
    gltfLoader.setDRACOLoader(draco);
    if(typeof MeshoptDecoder!=='undefined'){ gltfLoader.setMeshoptDecoder(MeshoptDecoder); }
    const fbxLoader = new THREE.FBXLoader();

    const drop=document.getElementById('drop'); const fileInput=document.getElementById('file');
    document.getElementById('loadModel').onclick=()=> fileInput.click();
    fileInput.onchange=(e)=>{ const f=e.target.files[0]; if(f) loadFromFile(f); };
    window.addEventListener('dragover',(e)=>{ e.preventDefault(); drop.style.display='flex'; });
    window.addEventListener('dragleave',(e)=>{ e.preventDefault(); drop.style.display='none'; });
    window.addEventListener('drop',(e)=>{ e.preventDefault(); drop.style.display='none'; const f=e.dataTransfer.files && e.dataTransfer.files[0]; if(f) loadFromFile(f); });

    let mixer=null;
    function placeAndFrame(root){ subject.clear(); mixer=null; subject.add(root); const box=new THREE.Box3().setFromObject(root); const size=new THREE.Vector3(); box.getSize(size); const center=new THREE.Vector3(); box.getCenter(center); root.position.sub(center); const maxDim=Math.max(size.x,size.y,size.z)||1.0; const scale=2.5/maxDim; root.scale.setScalar(scale); root.position.y+=1.2; traverseForSilhouette(root, forceSilhouette); frameSubject(); }

    function loadFromFile(file){
      const name=(file.name||'').toLowerCase(); const ext=name.split('.').pop();
      const reader=new FileReader();
      reader.onload=function(){
        const buffer=reader.result;
        if(ext==='glb' || ext==='gltf'){
          gltfLoader.parse(buffer,'', (gltf)=>{
            const root=gltf.scene || gltf.scenes[0]; placeAndFrame(root);
            if(gltf.animations && gltf.animations.length){ mixer=new THREE.AnimationMixer(root); mixer.clipAction(gltf.animations[0]).play(); }
            log('✅ Loaded GLTF/GLB: '+name);
          }, (err)=>{ log('❌ GLTF parse error: '+(err&&err.message?err.message:err)); console.error(err); });
        }else if(ext==='fbx'){
          try{ const obj=fbxLoader.parse(buffer,''); placeAndFrame(obj); log('✅ Loaded FBX: '+name); }
          catch(err){ log('❌ FBX parse error: '+(err&&err.message?err.message:err)); console.error(err); }
        }else{ log('⚠️ Unsupported file type: '+ext); }
      };
      reader.readAsArrayBuffer(file);
    }

    document.getElementById('toggleBackplate').onclick=()=> backplate.visible=!backplate.visible;
    document.getElementById('toggleLamps').onclick=()=> lamps.visible=!lamps.visible;
    let playing=true;
    document.getElementById('pause').onclick=()=> playing=!playing;
    document.getElementById('recenter').onclick=()=> frameSubject();
    let lastTap=0; window.addEventListener('click', ()=>{ const now=Date.now(); if(now-lastTap<300){ playing=!playing; } lastTap=now; });

    const clock=new THREE.Clock();
    function animate(){ requestAnimationFrame(animate); const dt=clock.getDelta(); const t=clock.elapsedTime; if(playing){ if(skater.parent){ skater.position.y=1.45+Math.sin(t*1.4)*0.16; board.position.y=0.95+Math.sin(t*1.5+1.2)*0.12; board.rotation.x=Math.sin(t*3.2)*0.5; board.rotation.z=Math.sin(t*2.1+1.2)*0.35; } if(mixer){ mixer.update(dt); } } renderer.render(scene,camera); }
    function onResize(){ const w=window.innerWidth||320, h=window.innerHeight||480; camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h,false); }
    window.addEventListener('resize', onResize, {passive:true}); onResize(); animate(); log('✅ Ready — GLB/GLTF (Draco/Meshopt) & FBX supported');
  }catch(err){ log('Error: '+(err.message||err)); console.error(err); }
})();

</script>
</body>
</html>
